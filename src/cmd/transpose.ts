/**
 * Transpose command module
 *
 * @packageDocumentation
 */

import fs from 'fs';

import * as tsm from 'ts-morph';

import {Options} from '../types';

import {conf, defaults} from '../conf/defaults';

import * as output from '../output/';

import * as util from '../util/';

import * as common from './common';

const atom_book_required_properties = ['properties', 'security', 'connection'];

export const transpose = {
	
	run: async (root:string, options?:Partial<Options>):Promise<void> => {
		
		conf.root = root;
		
		common.init_run(options);
		
		await transpose.command();
		
	},
	
	command: async ():Promise<void> => {
		
		output.start_loading('Transposing...');
		
		util.read_rc_file();
		
		const tmp_book_folder = `${conf.root}/${defaults.folder}/.tmp`;
		
		util.create_folder_if_doesnt_exists('tmp', tmp_book_folder);
		
		util.copy_file(
			'bkp',
			`${conf.root}/src/book.ts`,
			`${tmp_book_folder}/book.ts`
		);
		
		_manipulate_and_create_files(`${tmp_book_folder}/book.ts`);
		
		util.remove_folder_if_exists('tmp', tmp_book_folder);
		
		output.end_log(`Transpose completed.`);
		
	}
	
};

const _project_option = {
	manipulationSettings: {
		indentationText: tsm.IndentationText.Tab,
		quoteKind: tsm.QuoteKind.Single,
	}
};

// const _project = new tsm.Project(
//   {
//     manipulationSettings: {
//       indentationText: IndentationText.Tab,
//       quoteKind: QuoteKind.Single,
//     }
//   }
// );

function _pretty_books(){
	util.pretty(`${conf.root}/${defaults.folder}/server/books/atom.ts`);
}

function _manipulate_and_create_files(filepath:string){
	
	const action = `manipulating [src/book.ts]`;
	
	output.start_loading(`${action[0].toUpperCase()}${action.substr(1)}...`);
	
	output.verbose_log(`mnpl`, `Started ${action}.`);
	
	// let sourceFile = _project.addSourceFileAtPath(`${conf.root}/src/book.ts`);
	
	const _project = new tsm.Project(_project_option);
	
	let sourceFile = _project.addSourceFileAtPath(`${filepath}`);
	
	sourceFile = _replace_comments(sourceFile);
	sourceFile = _change_realtive_imports(sourceFile);
	
	const import_statements = _copy_imports(sourceFile);
	
	_create_bll_book(sourceFile, import_statements);
	_create_api_book(sourceFile, import_statements);
	_create_atom_book(sourceFile, import_statements);
	
	// sourceFile = _manipulate_atom_book(sourceFile);
	
	// const modified = sourceFile.print();
	
	// _create_manipulated_file(modified);
	
	_pretty_books();
	
	// _type_check_books();
	
}

function _replace_comments(sourceFile:tsm.SourceFile)
		:tsm.SourceFile{
	const node = sourceFile.getFirstChild();
	if(node){
		const comments = node.getLeadingCommentRanges();
		if(comments.length > 0){
			let new_comment = '';
			new_comment += `/**\n`;
			new_comment += ` *\n`;
			new_comment += ` * Autogenerated books from urn-cli\n`;
			new_comment += ` *\n`;
			new_comment += ` */\n`;
			const node_text = node.getText(true);
			const end = comments[0].getEnd();
			const no_comments = node_text.substr(end);
			node.replaceWithText(`${new_comment}${no_comments}`);
		}
	}
	return sourceFile;
}

// function _manipulate_atom_book(sourceFile:tsm.SourceFile)
//     :tsm.SourceFile{
//   output.start_loading(`Manipulating atom_book...`);
//   let book_decl = _find_atom_book_declaration(sourceFile);
//   if(book_decl){
//     book_decl = _remove_type_reference(book_decl);
//     book_decl = _clean_prop('bll', book_decl);
//     book_decl = _clean_prop('api', book_decl);
//     book_decl = _append_requried_book(book_decl, 'atom');
//     book_decl = _add_as_const(book_decl);
//   }
//   output.done_log('mnpl', 'Done manipulating atom_book.');
//   return sourceFile;
// }

function _create_a_book(
	sourceFile:tsm.SourceFile,
	import_statements:string[],
	book_name:string,
	keep_properties:string[],
	required_book_name:string
):tsm.SourceFile{
	output.start_loading(`Creating ${book_name}_book...`);
	const book_state = _find_atom_book_statement(sourceFile);
	if(book_state){
		const atom_book_state_text = book_state.getText();
		
		const _project = new tsm.Project(_project_option);
		
		const cloned_book_source = _project.createSourceFile(
			`${conf.root}/${defaults.folder}/server/books/${book_name}.ts`,
			atom_book_state_text,
			{ overwrite: true }
		);
		let cloned_book_decl = cloned_book_source
			.getFirstDescendantByKind(tsm.ts.SyntaxKind.VariableDeclaration);
		if(cloned_book_decl){
			cloned_book_decl = _remove_type_reference(cloned_book_decl);
			cloned_book_decl = _rename_book(book_name, cloned_book_decl);
			cloned_book_decl = _clean_all_but(keep_properties, cloned_book_decl);
			cloned_book_decl = _append_requried_book(cloned_book_decl, required_book_name);
			cloned_book_decl = _add_as_const(cloned_book_decl);
		}
		
		// const last = sourceFile.getLastChildByKind(tsm.ts.SyntaxKind.VariableStatement);
		// if(last){
		//   last.replaceWithText(last.getText() + cloned_book_source.getText());
		// }
		
		const required_imports = _get_required_imports(import_statements, cloned_book_source.getText());
		
		const filepath = `${conf.root}/${defaults.folder}/server/books/${book_name}.ts`;
		const text = required_imports.join('\n') + cloned_book_source.getText();
		_create_a_book_file(filepath, text);
		
	}
	output.done_log(book_name, `Created books/${book_name}.`);
	return sourceFile;
}

function _get_required_imports(import_statements:string[], text:string){
	
	const required_import_statements:string[] = [];
	
	const str_project = new tsm.Project({
		tsConfigFilePath: `${conf.root}/tsconfig.json`,
		skipFileDependencyResolution: true
	});
	for(let i = 0; i < import_statements.length; i++){
		const imp_state = import_statements[i];
		const str_source_file = str_project.createSourceFile(`file${i}.ts`, imp_state);
		const import_decls = str_source_file.getDescendantsOfKind(tsm.ts.SyntaxKind.ImportDeclaration);
		for(const decl of import_decls){
			const identifiers = decl.getDescendantsOfKind(tsm.ts.SyntaxKind.Identifier);
			for(const idf of identifiers){
				const idf_text = idf.getText();
				const regex = new RegExp(`\\b${idf_text}\\b`);
				if(regex.test(text)){
					required_import_statements.push(decl.getText());
				}
			}
		}
	}
	
	return required_import_statements;
}

function _create_atom_book(sourceFile:tsm.SourceFile, import_statements:string[])
		:tsm.SourceFile{
	return _create_a_book(sourceFile, import_statements, 'atom', atom_book_required_properties, 'atom');
}

function _create_api_book(sourceFile:tsm.SourceFile, import_statements:string[])
		:tsm.SourceFile{
	return _create_a_book(sourceFile, import_statements, 'api', ['api'], 'api');
}

function _create_bll_book(sourceFile:tsm.SourceFile, import_statements:string[])
		:tsm.SourceFile{
	return _create_a_book(sourceFile, import_statements, 'bll', ['bll'], 'bll');
}

function _clean_all_but(but:string[], var_decl:tsm.VariableDeclaration)
		:tsm.VariableDeclaration{
	output.start_loading(`Cleaning all properties but [${but}]...`);
	const book_expr = var_decl.getFirstChildByKind(tsm.ts.SyntaxKind.ObjectLiteralExpression);
	if(book_expr){
		const atom_names = book_expr.getChildrenOfKind(tsm.ts.SyntaxKind.PropertyAssignment);
		for(const atom_name of atom_names){
			const atom_def = atom_name.getFirstChildByKind(tsm.ts.SyntaxKind.ObjectLiteralExpression);
			if(atom_def){
				const atom_def_props = atom_def.getChildrenOfKind(tsm.ts.SyntaxKind.PropertyAssignment);
				for(const atom_def_prop of atom_def_props){
					if(!but.includes(atom_def_prop.getName())){
						atom_def_prop.remove();
					}
				}
			}
		}
	}
	output.done_verbose_log('props', `Removed all properties but [${but}].`);
	return var_decl;
}

// function _clean_prop(prop:string, var_decl:tsm.VariableDeclaration)
//     :tsm.VariableDeclaration{
//   output.start_loading(`Cleaning property [${prop}]...`);
//   const book_expr = var_decl.getFirstChildByKind(tsm.ts.SyntaxKind.ObjectLiteralExpression);
//   if(book_expr){
//     const atom_names = book_expr.getChildrenOfKind(tsm.ts.SyntaxKind.PropertyAssignment);
//     for(const atom_name of atom_names){
//       const atom_def = atom_name.getFirstChildByKind(tsm.ts.SyntaxKind.ObjectLiteralExpression);
//       if(atom_def){
//         const atom_def_props = atom_def.getChildrenOfKind(tsm.ts.SyntaxKind.PropertyAssignment);
//         for(const atom_def_prop of atom_def_props){
//           if(atom_def_prop.getName() === prop){
//             atom_def_prop.remove();
//           }
//         }
//       }
//     }
//   }
//   output.done_verbose_log('prop', `Removed property [${prop}].`);
//   return var_decl;
// }

function _rename_book(book_name:string, var_decl:tsm.VariableDeclaration)
		:tsm.VariableDeclaration{
	const identifier = var_decl.getFirstChildByKind(tsm.ts.SyntaxKind.Identifier);
	if(identifier){
		identifier.replaceWithText(`${book_name}_book`);
	}
	return var_decl;
}

function _get_variable_content(source:tsm.SourceFile, variable_name:string)
		:string{
	const states = source.getChildrenOfKind(tsm.ts.SyntaxKind.VariableStatement);
	for(const state of states){
		const var_decl = state.getFirstDescendantByKind(tsm.ts.SyntaxKind.VariableDeclaration);
		if(var_decl){
			if(var_decl.getName() === variable_name){
				const syntax_list = var_decl.getFirstDescendantByKind(tsm.ts.SyntaxKind.SyntaxList);
				if(syntax_list){
					return syntax_list.getText();
				}
			}
		}
	}
	return '';
}

function _add_book_from_file(
	book_decl:tsm.VariableDeclaration,
	required_book_name:string,
	books_file_path:string
){
	const book_content = fs.readFileSync(books_file_path, 'utf8');
	
	const _project = new tsm.Project(_project_option);
	
	const core_books_source = _project.createSourceFile(
		`${conf.root}/${defaults.folder}/cloned_${required_book_name}.ts`,
		book_content,
		{ overwrite: true }
	);
	const core_var_content = _get_variable_content(core_books_source, required_book_name);
	const syntax_list = book_decl.getFirstDescendantByKind(tsm.ts.SyntaxKind.SyntaxList);
	if(syntax_list){
		syntax_list.replaceWithText(core_var_content + syntax_list.getText());
	}
}

function _add_core_books(book_decl:tsm.VariableDeclaration, required_book_name:string){
	let core_repo_path = `${defaults.folder}/${defaults.repo_folder}`;
	switch(conf.repo){
		case 'core':{
			break;
		}
		case 'ntl':
		case 'web':{
			core_repo_path = `${defaults.folder}/${defaults.repo_folder}/core`;
			break;
		}
	}
	const required_books_path = `${conf.root}/${core_repo_path}/books.ts`;
	_add_book_from_file(book_decl, required_book_name, required_books_path);
	
}

function _add_web_books(book_decl:tsm.VariableDeclaration, required_book_name:string){
	const web_repo_path = `${defaults.folder}/${defaults.repo_folder}`;
	const required_books_path = `${conf.root}/${web_repo_path}/books.ts`;
	_add_book_from_file(book_decl, required_book_name, required_books_path);
}

function _add_ntl_books(book_decl:tsm.VariableDeclaration, required_book_name:string){
	const ntl_repo_path = `${defaults.folder}/${defaults.repo_folder}`;
	const required_books_path = `${conf.root}/${ntl_repo_path}/books.ts`;
	_add_book_from_file(book_decl, required_book_name, required_books_path);
}

function _append_requried_book(book_decl:tsm.VariableDeclaration, required_book_name:string)
		:tsm.VariableDeclaration{
	output.start_loading(`Adding required books...`);
	switch(conf.repo){
		case 'web':{
			_add_web_books(book_decl, required_book_name);
			break;
		}
		case 'ntl':{
			_add_ntl_books(book_decl, required_book_name);
		}
	}
	_add_core_books(book_decl, required_book_name);
	output.done_verbose_log(`requ`, `Added required books.`);
	return book_decl;
}

function _change_realtive_imports(sourceFile:tsm.SourceFile)
		:tsm.SourceFile{
	output.start_loading(`Changing relative imports...`);
	const import_decls = sourceFile.getChildrenOfKind(tsm.ts.SyntaxKind.ImportDeclaration);
	for(const import_decl of import_decls){
		_change_realtive_import(import_decl);
	}
	output.done_log('impr', 'Changed relative imports.');
	return sourceFile;
}

function _add_as_const(book_decl:tsm.VariableDeclaration){
	output.start_loading(`Adding as const...`);
	book_decl.replaceWithText(book_decl.getText() + ' as const');
	output.done_verbose_log(`asco`, `Added as const.`);
	return book_decl;
}

function _change_realtive_import(node:tsm.Node)
		:tsm.Node{
	output.start_loading(`Changing relative imports...`);
	const str_lit = node.getFirstChildByKind(tsm.ts.SyntaxKind.StringLiteral);
	if(str_lit){
		const text = str_lit.getText();
		if(text.includes('./')){
			const replace = text.replace('./','../../../src/');
			str_lit.replaceWithText(replace);
			output.verbose_log(`impo`, `Changed [${text}] to [${replace}].`);
		}
	}
	return node;
}

// function _create_manipulated_file(text:string){
//   output.start_loading(`Writing manipulated book...`);
//   fs.writeFileSync(`${conf.root}/${defaults.folder}/server/books/atom.ts`, text);
//   output.done_log(`trns`, `Manipulated books copied to [${defaults.folder}/server/books/atom.ts].`);
// }

function _remove_type_reference(book_decl:tsm.VariableDeclaration){
	output.start_loading(`Removing type reference...`);
	const type_ref = book_decl.getFirstChildByKind(tsm.ts.SyntaxKind.TypeReference);
	if(type_ref){
		book_decl.removeType();
	}
	output.done_verbose_log('type', `Type reference removed.`);
	return book_decl;
}

// function _find_atom_book_declaration(sourceFile:tsm.SourceFile)
//     :tsm.VariableDeclaration | undefined{
//   output.start_loading(`Looking for atom_book declaration...`);
//   const var_states = sourceFile.getChildrenOfKind(tsm.ts.SyntaxKind.VariableStatement);
//   for(const state of var_states){
//     const var_decl_list = state.getFirstChildByKind(tsm.ts.SyntaxKind.VariableDeclarationList);
//     if(var_decl_list){
//       const var_decl = var_decl_list.getFirstChildByKind(tsm.ts.SyntaxKind.VariableDeclaration);
//       if(var_decl){
//         const name = var_decl.getName();
//         if(name === 'atom_book'){
//           output.verbose_log(`book`, `Declaration of atom_book found.`);
//           return var_decl;
//         }
//       }
//     }
//   }
//   output.verbose_log('book', `Cannot find atom_book`);
//   return undefined;
// }

function _find_atom_book_statement(sourceFile:tsm.SourceFile)
		:tsm.VariableStatement | undefined{
	output.start_loading(`Looking for atom_book statement...`);
	const var_states = sourceFile.getChildrenOfKind(tsm.ts.SyntaxKind.VariableStatement);
	for(const state of var_states){
		const var_decl_list = state.getFirstChildByKind(tsm.ts.SyntaxKind.VariableDeclarationList);
		if(var_decl_list){
			const var_decl = var_decl_list.getFirstChildByKind(tsm.ts.SyntaxKind.VariableDeclaration);
			if(var_decl){
				const name = var_decl.getName();
				if(name === 'atom_book'){
					output.verbose_log(`book`, `Statement of atom_book found.`);
					return state;
				}
			}
		}
	}
	output.verbose_log('book', `Cannot find atom_book`);
	return undefined;
}

function _create_a_book_file(filepath:string, text:string){
	output.start_loading(`Creating book file [${filepath}]...`);
	util.sync_exec(`rm -f ${filepath}`);
	util.sync_exec(`touch ${filepath}`);
	let comment = '';
	comment += `/**\n`;
	comment += ` *\n`;
	comment += ` * Autogenerated book from urn-cli\n`;
	comment += ` *\n`;
	comment += ` */\n`;
	const content = comment + text;
	fs.writeFileSync(filepath, content);
	util.pretty(filepath);
	output.done_verbose_log(`book`, `Created book file [${filepath}].`);
}

function _copy_imports(sourceFile:tsm.SourceFile){
	output.start_loading(`Copying import statements...`);
	const import_states = sourceFile.getChildrenOfKind(tsm.ts.SyntaxKind.ImportDeclaration);
	const states:string[] = [];
	for(const state of import_states){
		states.push(state.getText());
	}
	output.verbose_log('book', `Copied import statements.`);
	return states;
}

// function _type_check_books(){
//   // ****
//   // TS CHECKER WILL CHECK IF THE ERROR IS 6133 [is declared but never used]
//   // ****
//   // const file_paths = [`${conf.root}/${defaults.folder}/server/books/atom.ts`];
//   // const _project = new tsm.Project({
//   //   tsConfigFilePath: `${conf.root}/tsconfig.json`,
//   //   skipFileDependencyResolution: true
//   // });
//   // _project.addSourceFilesAtPaths(file_paths);
//   // _project.emitToMemory();
//   // for (const diagnostic of _project.getPreEmitDiagnostics()){
//   //   const filepath = diagnostic.getSourceFile()?.getFilePath();
//   //   if(filepath === file_paths[0]){
//   //     if(diagnostic.getCode() === 6133){
//   //       console.log(diagnostic.getMessageText());
//   //     }
//   //   }
//   // }
//   // const _project = new tsm.Project({
//   //   tsConfigFilePath: `${conf.root}/tsconfig.json`,
//   //   skipFileDependencyResolution: true
//   // });
//   // _project.createSourceFile('file.ts','');
// }



